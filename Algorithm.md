# Algorithm

1. 버블 정렬
2. 삽입 정렬
3. 선택 정렬
4. 합병 정렬 (merge sort)
5. 퀵 정렬
6. 이진탐색
7. BFS
8. DFS

[출처](https://gmlwjd9405.github.io/tags#algorithm)



## 버블 정렬 (Bubble Sort)

서로 인접한 두 요소를 검사하여 정렬하는 알고리즘이다. 인접한 두 요소가 순서대로 되어있지 않으면 서로 교환한다.

구현이 간단하지만 비효율적이다.

최선 : n^2 / 평균 n^2 / 최악 n^2



## 삽입 정렬 (Insertion Sort)

앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입하는 정렬이다.

두번째 요소부터 시작하여 자신보다 큰 요소를 발견하였으면 그 요소를 뒤로 이동 시키고, 자신보다 작은 요소를 발견하였으면 바로 뒷자리에 자신을 넣어준다.

구현이 간단하지만 비효율적이다.

최선 - n 이동 없이 1번의 비교만 이루어지는 경우

최악 - n^2 모든 요소마다 비교를 진행하는 경우

평균 - n^2



## 선택 정렬 (Selection Sort)

정렬되지 않은 부분에서 최솟값을 찾아 정렬된 부분 끝에 추가해준다. 앞에서부터 정렬이 된다.

자료 이동 횟수가 미리 결정되지만 안정서을 만족하지 않는다. 같은 값이 있는 경우 상대적인 위치가 변경될 수 있다.

항상 최솟값의 위치를 찾아 변경해줘야 하므로,, n^2

최선 : n^2 / 평균 n^2 / 최악 n^2



## 합병 정렬 (Merge Sort)

분할 정복 알고리즘의 하나이다.

하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한다. 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.

배열로 구성하면 임시 배열이 필요하다. 리스트 크기가 큰 경우에는 이동 횟수가 많으므로 큰 시간 낭비를 초래한다. 하지만 입력 데이터가 무엇이든 정렬되는 시간이 동일한 안정적인 방법이다.

순환 호출 logn * 비교 n

최선 : nlogn / 평균 nlogn / 최악 nlogn

## 



### Q. 버블 정렬이 무엇인가요?

인접한 두 요소를 비교하면서 정렬해 나가는 알고리즘입니다. 구현이 간단하지만 시간 복잡도가 항상 n^2으로 비효율적입니다.

### Q. 삽입 정렬이 무엇인가요?

정렬된 부분에서 자신의 위치를 찾아 삽입하는 알고리즘입니다. 오름차순의 경우, 정렬된 부분에서 자신보다 큰 값을 만나면 뒤로 미루고 자신보다 작은 값을 만나면 바로 뒤에 넣어주면 됩니다. 구현이 간단하지만 비효율적입니다. 시간 복잡도는 최선은 n, 최악의 경우는 n^2 입니다.

### Q. 선택 정렬이 무엇인가요? 

정렬되지 않은 부분에서 최솟값을 찾아 정렬된 부분에 추가해주는 알고리즘입니다. 앞에서부터 정렬되며, 자료 이동 횟수가 미리 결정되지만 같은 수가 있는 경우 상대적인 위치가 변경될 수 있어 안정적이지 않습니다. 시간 복잡도는 항상 n^2 입니다.

### Q. 합병 정렬이 무엇인가요?

분할 정복 알고리즘의 하나입니다. 하나의 리스트를 균등한 두 개의 크기로 분할합니다. 분할된 리스트를 정렬하고 다시 하나로 합하여 정렬하는 방법입니다. 임시 배열이 필요하고 리스트 크기가 큰 경우에는 이동 횟수가 많지만 입력 데이터 값이 무엇이든 정렬되는 시간이 nlogn으로 동일한 안정적인 방법입니다.