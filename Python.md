# Python

1. 매직메소드 ✔️

2. timsort ✔️

3. generator ✔️

4. iterator ✔️

5. lambda ✔️

6. Counter

    

## 매직 메소드

미리 정의되어 있는 특별한 이름을 가진 메소드들을 재정의 함으로써 파이썬 인터프리터가 데이터 객체를 만들거나, 표현하거나, 연산을 하는데 도움을 줄 수 있다. 

- `__new__(cls[, ...])`: 새로운 인스턴스를 만들때 제일 **처음**으로 실행되는 메소드. 새로운 `object`를 반환해줘야 한다.
- `__init__(self[, ...])`: 인스턴스가 `__new__`로 생성되고 나서 호출되는 메소드. 인자를 받아서 내부에 지정해 줄 수 있다.
- `__del__(self)`: 객체의 **소멸**에 될때 해야할 일을 지정할 수 있다. `del`키워드를 호출한다고 해서 `__del__()`이 바로 호출되지는 않는다. 내부에 있는 레퍼런스 카운터가 0가 되면 소멸하고, 객체 소멸시 파일을 닫아준다거나 할때 사용할 수 있다.
- `__str__(self)`: 객체를 나타내는 비공식적인 문자열이지만 객체를 이해하기 쉽게 표현할 수 있는 문자열이다. `str()`로 호출 할 수 있다. 마찬가지로 `string`타입의 문자열을 반환해야 한다. 
- `__get__(self, instance, owner)`: 특정 오브젝트의 값을 참조할때 호출
- `__set__(self, instance, value)`: 특정 오브젝트의 값을 변경할때 호출
- `__delete__(self, instance)`: 특정 오브젝트의 값을 삭제할때 호출

[출처](https://corikachu.github.io/articles/python/python-magic-method)



## TimSort

merge sort, insert sort를 기반으로 하는 알고리즘이다. 최악의 경우에도 O(nlogn) 이 되는 안정적인 알고리즘이다.

삽입 정렬을 사용하여 작은 조각을 정렬 한 다음, 병합 정렬의 병합을 사용하여 조각을 병합한다.

array를 run이라는 블록으로 나눈다. 삽입 정렬을 사용하여 나누어진 run을 하나씩 정렬하고 병합 정렬을 사용한다. array가 run 크기보다 작으면 삽입 정렬을 사용하여 정렬 된다. run의 크기는 32 또는 64가 될 수 있다.



## Generator

iterator를 생성해주는 함수이다. iterator은 next() 메소드를 이용해 데이터에 순차적으로 접근이 가능한 object 이다.

일반적인 함수와 비슷하게 생겼지만 `yield` 구문을 사용해 원하는 시점에 반환하고 처리를 다시 시작할 수 있다. 진입점이 여러개라고 할 수 있다. 따라서 원하는 시점에 원하는 데이터를 받을 수 있게 된다.

> 함수가 실행 중 yield 를 만날 경우, 그 상태로 정지되며, 반환 값을 next()를 호출한 쪽으로 전달하게 된다. 이후 함수는 종료되는 것이 아니라 그 상태로 유지되게 된다.



list, set, dict 는 iterable(member를 하나씩 차례로 반환 가능한 object) 하기에 유용하게 쓰이지만 모든 값을 메모리에 담고 있어야 하기 때문에 큰 값을 다룰 때는 별로 좋지 않다. 제너레이터를 사용하면 그떄 그때 필요한 값만 받아 쓰기 때문에, 모든 값을 메모리에 들고 있을 필요가 없다. 즉 메모리 효율성을 높일 수 있다.



## Iterator

값을 차례대로 꺼낼 수 있는 객체

iterable객체의 메소드로 객체를 생성할 수 있다.



## Lambda

익명 함수

식 형태로 함수를 간단하게 작성할 수 있어 다른 함수의 인수로 넣을 때 주로 사용한다.



## Counter

동일한 값의 자료가 몇 개인지 파악하는데 사용하는 객체이다.

딕셔너리 형태로 넣어줘야 하고, 결과도 딕셔너리 형태로 받을 수 있다.



---

### Q. 파이썬 기본 정렬에 사용되는 알고리즘은 무엇인가요?

TimSort로 insert sort 와 merger sort의 개념을 결합한 정렬 알고리즘 입니다. 배열을 run이라는 32 또는 64 바이트 크기의 블록으로 나눕니다. 그 후 insert sort 를 사용해 run 블록 각각을 정렬하고, merge sort 를 사용해 이들을 합병합니다. 만약 배열의 크기가 run의 크기보다 작다면 insert sort 를 사용해 정렬합니다. 최악의 경우에도 nlogn의 시간이 걸리는 안정적인 알고리즘 입니다.



### Q. 리스트와 튜플 차이는 무엇인가요?

두 타입 모두 순서를 가지는 자료형입니다. 리스트는 가변적이고, 튜플은 불변적입니다. 리스트는 요소를 추가하는 동작을 빠르게 수행할 수 있도록 더 많은 공간을 저장해둡니다. 튜플은 정해진 공간만 사용하므로 공간 효율적입니다.



### Q. 딕셔너리와 set의 차이는 무엇인가요?

딕셔너리는 key-value 쌍으로 표현되는 자료형입니다. key 를 통해 값을 조회합니다. set은 중복을 허용하지 않고, 순서가 없습니다. 두 자료형 모두 가변적입니다.



### Q. Generator는 무엇인가요? ⭐️

iterator를 생성해 주는 함수입니다. next() 메소드를 통해 실행됩니다. yield문을 만나면 암시적으로 return이 호출되며, 함수를 그 상태로 유지하게 할 수 있습니다. 다음 next()메소드를 실행할 때는 중단된 시점부터 다시 시작 됩니다. list 등 다른 iteratable 한 객체는 모든 값을 메모리에 담아둬야 하지만, 제너레이터는 그 때 그 때 필요한 값만 받아 쓰기 때문에 메모리 효율적이라고 할 수 있습니다.



### Q. iterator 는 무엇인가요?

값을 차례대로 꺼낼 수 있는 객체입니다. iterable객체의 메소드로 객체를 생성할 수 있습니다.

iterable 객체는 반복 가능한 객체로 list, dict, set 등을 예시로 들 수 있습니다.



### Q. lambda 는 무엇인가요?

익명 함수를 만드는 방법입니다. 식 형태를 이용해 함수를 간편하게 작성할 수 있어서 다른 함수의 인자로 넣을 때 주로 사용합니다.



### Q. Counter 는 무엇인가요

동일한 키를 가지는 자료가 몇 개인지 파악하는데 사용하는 객체입니다. 딕셔너리 형태로 넣어주고 딕셔너리 형태로 결과를 받아볼 수 있습니다.